/*

    Autoimpedance driver for the electric imp
    
    USAGE:

*/

class ZSensor {

    // i2c object
    _i2c  = null;
	_clock = null;
    
    // Shift 7-bit address to 8-bit address required by the imp
    static ADDRESS = 0x0D << 1;
    
    // User changeable properties
    numSteps = null;
    startHz = null;
    incHz = null;
    nocyc = null;
    voltage = null;
    
    // Internal variables
    ctl = null; // 16-bit control register
    cyc = null; // 16-bit no. cycles register
    
    // Results
    tmp = null; // temperature
    zR = null; // real impedance component
    zI = null; // imaginary impedance components
    ohm = null; // impedance magnitude
    rad = null; // relative phase
    
    
    // Construct the  Object
    constructor(i2c, clock) {
        _i2c  = i2c;
		_clock = clock;
		
		// Default sweep values
		numSteps = 10;
        startHz = 5e3;
        incHz = 1e3;
        nocyc = 1; 
        
        // Default voltage
        voltage = 0.2;
        
        // Default ctl 
        ctl = 0xA000; // power-down mode
        cyc = 0x0001; // 1 cycle

    }
    
    function getZ() {
        return -1;
    }
    
    function setSweepParameters() {
        
        // Start frequency
        local D = getFreqCode(startHz);
        _i2c.write(ADDRESS, 0x82 + (D >> 16).tochar()); 
        _i2c.write(ADDRESS, 0x83 + (D >> 8).tochar()); 
        _i2c.write(ADDRESS, 0x84 + D.tochar()); 
        
        // Frequency increment
        D = getFreqCode(incHz);
        _i2c.write(ADDRESS, 0x85 + (D >> 16).tochar()); 
        _i2c.write(ADDRESS, 0x86 + (D >> 8).tochar()); 
        _i2c.write(ADDRESS, 0x87 + D.tochar()); 
        
        // Number of steps
        D = numSteps;
        _i2c.write(ADDRESS, 0x88 + (D >> 8).tochar()); 
        result = _i2c.write(ADDRESS, 0x89 + D.tochar()); 
        
        return result;
    }
    
    
    function standby() {
        
        // Standby command
        D = (ctl & ~(0xF0)) | 0xB0;
        result = _i2c.write(ADDRESS, 0x80 + D); 
        
        return result;
    }
    
    function startSweep() {
        
        // Start sweep command
        D = (ctl & ~(0xF0)) | 0x20;
        result = _i2c.write(ADDRESS, 0x80 + D); 
        
        return result;
    }
    
    function incrementFreq() {
        
        // Increment frequency command
        D = (ctl & ~(0xF0)) | 0x30;
        result = _i2c.write(ADDRESS, 0x80 + D); 
        
        return result;
    }
    
    function repeatFreq() {
        
        // Repeat frequency command
        D = (ctl & ~(0xF0)) | 0x40;
        result = _i2c.write(ADDRESS, 0x80 + D); 
        
        return result;
    }
    
    function measureTemp() {
        
        // Measure temperature command
        D = (ctl & ~(0xF0)) | 0x90;
        result = _i2c.write(ADDRESS, 0x80 + D); 
        
        return result;
    }
    
    function powerDown() {
        
        // Power-down command
        D = (ctl & ~(0xF0)) | 0xA0;
        result = _i2c.write(ADDRESS, 0x80 + D); 
        
        return result;
    }

    function getFreqCode(fHz) {
        
        // Covert to 24-bit code
        local value = math.floor((fHz.tofloat() / (_clock.freqHz / 4.0)) * 2^27);

		return (value & 0x00FFFFFF);
    }
    
    function setStartHz(fHz){
        
        if (fHz < 0) {
            return -1;
        }
        else {
            
            startHz = fHz;
            
            // Success
            return 0;
        }
    }
    
    function setIncHz(fHz){
        
        if (fHz < 0) {
            return -1;
        }
        else {
            
            incHz = fHz;
            
            // Success
            return 0;
        }
    }
    
    function setNumSteps(n){
        
        if (n < 0 || f > 511) {
            return -1;
        }
        else {
            
            numSteps = n;
            
            // Success
            return 0;
        }
    }
    
    function setVoltage(v) {
        
        if (v > 0 && v < 0.4) {
            
            // 200 mV command
            ctl = (ctl & ~(0x06)) | 1 << 1;
            voltage = 0.2;
        }
        else if (v >= 0.4 && v < 1.0) {
            
            // 400 mV command
            ctl = (ctl & ~(0x06)) | 2 << 1;
            voltage = 0.4;
        }
        else if (v >= 1.0 && v < 2.0) {
            
            // 400 mV command
            ctl = (ctl & ~(0x06)) | 3 << 2;
            voltage = 1.0;
        }
        else if (v >= 2.0) {
            
            // 400 mV command
            ctl = (ctl & ~(0x06)) | 0 << 2;
            voltage = 2.0;
        }
        else {
            
            // Invalid voltage requested
            return -1;
        }
        
        // Set the voltage on the chip
        _i2c.write(ADDRESS, 0x80 + (ctl >> 8).tochar());
        result = _i2c.write(ADDRESS, 0x81 + ctl.tochar()); 
        
        if (result == 0) {
            
            // Success
            voltage = 0.2;
            return voltage;
        }
        else {
            
            // Return i2c error
            return result;
        }
    }
    
    function setNumSettleCycles(n) {
        
        if (n > 0 && n < 511) {
            
            // Set number of cycles register to n
            cyc = (cyc & ~(0x10)) | (n >> 8).tochar();
            cyc = (cyc & ~(0x0F)) | n.tochar();
            
            // Set the number of cycles on the chip
            _i2c.write(ADDRESS, 0x8A + (cyc >> 8).tochar());
            result = _i2c.write(ADDRESS, 0x8B + cyc.tochar()); 
            
            return result;
            
        }
        else {
            
            // Invalid number of cycles
            return -1;
        }
    }
    
    function queryStatus() {
        
        result = _i2c.read(ADDRESS, 0x8F, 1)[0];
    }
    
    function getZ() {
        
        // Read the impedance value registers
        zR = (zR & ~(0xF0)) | _i2c.read(ADDRESS, 0x94, 1)[0] << 8;
        zR = (zR & ~(0x0F)) | _i2c.read(ADDRESS, 0x95, 1)[0];
        zI = (zR & ~(0xF0)) | _i2c.read(ADDRESS, 0x96, 1)[0] << 8;
        zI = (zR & ~(0x0F)) | _i2c.read(ADDRESS, 0x97, 1)[0];
        
        // Convert to resistance and phase values
        
        
    }
}

class Pot {

    // i2c object
    _i2c  = null;
    
    // Shift 7-bit address to 8-bit address required by the imp
    static ADDRESS = 0x2D << 1;
    
    // Resistances of wiper switch and A --> B terminals
    static Rw   = 50;
    static Rab  = 100e3;
    
    // True A --> W resistance
    Raw = null;

    // Construct the Object
    constructor(i2c) {
        _i2c  = i2c;
    }
    
    function setR(R) {
	    /*
		Sets the A --> W resistance
		
        Inputs:
            R: Resistance value, in ohms, less than 100k
        
        Returns:
            i2c.write error code
        */
        
        if (R > Rab) {
            return -1;
        }
        else {
            
            // Get data register value
            local D = 256.0 + 256.0*(2.0*Rw - R)/Rab;
            
            // Configure the resistance from A -> W terminals
            local i2c_result = _i2c.write(ADDRESS, "\00" + D.tochar());
            
            // Log the true clock  A -> W resistance
            Raw = Rab*(256.0 - math.floor(D))/256.0 + 2*Rw;
            
            // Return i2c result
            return i2c_result;   
            
        }
    }
}

class Clock {

    // i2c object
    _i2c  = null;
    
    // Shift 7-bit address to 8-bit address required by the imp
    static ADDRESS  = 0x17 << 1;
    
    // Output configuration; 2 = CLK only
    static POW = 2; 
    
    // Current frequency setting
    freqHz = null;
    
    // Construct the Object
    constructor(i2c) {
        _i2c  = i2c;
    }
    
    function setHz(fHz) {
        /*
		Sets the clock frequency
		
        Inputs:
            fHz: integer specifying oscillator frequency, e.g. 50e3 for 50 kHz
        
        Returns:
            i2c.write error code
        */
        
        if (fHz <= 1e3 || fHz > 68e6) {
            return -1;
        }
        else {
            
            // Calculate the OCT and DAC register values
            local oct = math.floor(3.322*math.log10(fHz/1039.0),0).tointeger();
            local dac = round(2048.0-(2078.0*math.pow(2,10.0 + oct))/fHz,0).tointeger();
        
            // Configure the clock frequency
            local D = oct << 12 | dac << 2 | POW;
            local i2c_result = _i2c.write(ADDRESS, (D >> 8).tochar() + D.tochar()); 
		
		    // Log the true clock frequency
		    freqHz = math.pow(2,oct.tofloat())*(2078.0/(2-dac.tofloat()/1024.0));

            // Return i2c result
            return i2c_result;  
        }
  
    }
    
    function round(val, decimalPoints) {
        local f = math.pow(10, decimalPoints) * 1.0;
        local newVal = val * f;
        newVal = math.floor(newVal + 0.5)
        newVal = (newVal * 1.0) / f;
 
        return newVal;
    }
}

class ShiftReg {
    
    // Serial, RClock, and SClock pins
    ser = null;
    rck = null; 
    sck = null; 
    
    // Output register
    out = 0
    // Register bit meanings
    // b0-3:    MUX16 address
    // b4:      0:  MUX16A      1: MUX16B
    // b5-6     00: Ztest       11: Plate mode
    // b7       0:  Plate off   1: Plate on
    
    // Construct the Object
    constructor() {
        
        hardware.pin2.configure(DIGITAL_OUT);
        hardware.pin5.configure(DIGITAL_OUT);
        hardware.pin7.configure(DIGITAL_OUT);
        
        rck = hardware.pin2;
        sck = hardware.pin5;
        ser = hardware.pin7;
        
        // Bring RClock and SClock HIGH to start
        rck.write(1);
        sck.write(1);
        
        // Zero the output pins
        clear();

    }
    
    function clear() {
        /*
		Clears the 8-bit output state of the 74HC95 register
		
        Inputs:
            N/A
        
        Returns:
            N/A
        */
        
        setByte(0);
    }
    
    function setByte(byte) {
        /*
		Sets the 8-bit state resiter of the 74HC95
		
        Inputs:
            Byte: byte specifying parallel port state, e.g. 170 = 10101010
        
        Returns:
            Error code
        */
        
        if (byte > 255) {
            
            // Value too large
            return -1;
        }
        else {
            
            out = byte;
            
            // Success
            return 0;
        }   
            
    }
    
    function setBit(idx, val) {
        /*
		Sets a single specified bit within the 8-bit state register of the 74HC95
		
        Inputs:
            idx: position of bit to apply val; 0 though 7
            val: value of position idx; 0 or 1
            
        Returns:
            Error code
        */
        
        if (idx > 7 || idx < 0) {
            
            // idx too large or negative
            return -1;
        }
        else {
            
            if (val > 1 || val < 0) {
                
                // Val must be 0 or 1
                return -1;
            }
            else {
                
                // Set single bit
                out = (out & ~(1 << idx)) | val << idx;

                // Success
                return 0;
            }


        } 
        
    }
    
    function update() {
        /*
		Updates the output pins of the 74HC95 based upon the value of this.out
		
        Inputs:
            N/A
        
        Returns:
            N/A
        */
        
        rck.write(0);
            
        for (local idx = 7; idx >= 0; idx -= 1) {
            
            sck.write(0);
            ser.write(out >> idx & 1);
            sck.write(1);
        }
        
        rck.write(1);
    }

}

class Mux {
    
    // Shift register object
    _sr  = null;
    
    // Construct the Object
    constructor(sr) {
        _sr  = sr;
    }
    
    function setMode(mode) {
        /*
		Sets the mode of the autoimpedance board. Available modes are impedance
		testing and plating modes.
		
        Inputs:
            mode:   "ztest" to select impedance testing mode
                    "plate" to select plating mode
            
        Returns:
            Error code
        */

        switch (mode) {
            case "ztest":
                _sr.setBit(5, 0);
                _sr.setBit(6, 0);
                _sr.update();
                break;
            
            case "plate":
                _sr.setBit(5, 1);
                _sr.setBit(6, 1);
                _sr.update();
                break;
                
            default:
                sq_throwerror(mode,"invalid mode.");
                return -1;
        }
    }
    
    function setChannel(chan) {
        /*
		Selects the channel to be measured or plated.
		
        Inputs:
            chan: Channel number; 0-31
            
        Returns:
            Error code
        */
        
        if (chan >= 32 || chan < 0) {
            
            // Channel number is too high or negative
            return -1;   
        }
        else {
            
            // Set the MUX16 address
            _sr.out = (_sr.out & ~0x0F) | chan
            
            // Select which MUX16 to use
            if (chan <= 15) {
                _sr.setBit(4, 0) // MUX16b
            }
            else {
                _sr.setBit(4, 1) // MUX16a
            }
            
            server.log(_sr.out);
            
            _sr.update();
            
            // Success
            return 0;
        }
    }
}


// Configure i2c bus
hardware.i2c89.configure(CLOCK_SPEED_100_KHZ);

// Assign globals
pot <- Pot(hardware.i2c89);
clock <- Clock(hardware.i2c89);
zsensor <- ZSensor(hardware.i2c89,clock);
sr <- ShiftReg();
mux <- Mux(sr);

// Test script
server.log("Autoimpedance is running...")


local result = clock.setHz(10e3); 
if (result == 0) {
    server.log("LTC6904 clock frequency set to " + clock.freqHz + " Hz.");
}


local result = pot.setR(20e3); 
if (result == 0) {
    server.log("AD5245 A->W resistance set to " + pot.Raw + " Ohms.");
}


mux.setMode("ztest");
mux.setChannel(5);
