/*

    Autoimpedance driver for the electric imp
    
    USAGE:

*/

class ZSensor {

    // i2c object
    _i2c  = null;
	_clock = null;
    
    static ADDRESS = 0x0D;
    numSteps = [null];
    startHz = [null];
    incHz = [null];

    // Construct the  Object
    constructor(i2c, clock) {
        _i2c  = i2c;
		_clock = clock;
    }
    
    function getZ() {
        return -1;
    }
    
    function getFreqCode(fHz) {
        
        local value = (fHz / (clock.freqHz / 4)) * 2^27;
		local code = [null];
 
        code[0] = (value & 0xFF0000) >> 0x10;
        code[1] = (value & 0x00FF00) >> 0x08;
        code[2] = (value & 0x0000FF);
        
		return code;
    }
    
    //function setStartHz(fHz){
        //startHz = fHz;
    //}
    
    //function setIncHz(fHz){
        //incHz = fHz;
    //}
    
   // function setNumSteps(N){
        //numSteps = N;
    //}
}

class Pot {

    // i2c object
    _i2c  = null;
    
    // Shift 7-bit address to 8-bit address required by the imp
    static ADDRESS = 0x2D << 1;
    
    // Resistances of wiper switch and A --> B terminals
    static Rw   = 50;
    static Rab  = 100e3;
    
    // True A --> W resistance
    Raw = null;

    // Construct the Object
    constructor(i2c) {
        _i2c  = i2c;
    }
    
    function setR(R) {
	    /*
		Sets the A --> W resistance
		
        Inputs:
            R: Resistance value, in ohms, less than 100k
        
        Returns:
            i2c.write error code
        */
        
        if (R > Rab) {
            return -1;
        }
        else {
            
            // Get data register value
            local D = 256.0 + 256.0*(2.0*Rw - R)/Rab;
            
            // Configure the resistance from A -> W terminals
            local i2c_result = _i2c.write(ADDRESS, "\00" + D.tochar());
            
            // Log the true clock  A -> W resistance
            Raw = Rab*(256.0 - math.floor(D))/256.0 + 2*Rw;
            
            // Return i2c result
            return i2c_result;   
            
        }
    }
}

class Clock {

    // i2c object
    _i2c  = null;
    
    // Shift 7-bit address to 8-bit address required by the imp
    static ADDRESS  = 0x17 << 1;
    
    // Output configuration; 2 = CLK only
    static POW = 2; 
    
    // Current frequency setting
    freqHz = null;
    
    // Construct the Object
    constructor(i2c) {
        _i2c  = i2c;
    }
    
    function setHz(fHz) {
        /*
		Sets the clock frequency
		
        Inputs:
            fHz: integer specifying oscillator frequency, e.g. 50e3 for 50 kHz
        
        Returns:
            i2c.write error code
        */
        
        if (fHz <= 1e3 || fHz > 68e6) {
            return -1;
        }
        else {
            
            // Calculate the OCT and DAC register values
            local oct = math.floor(3.322*math.log10(fHz/1039.0),0).tointeger();
            local dac = round(2048.0-(2078.0*math.pow(2,10.0 + oct))/fHz,0).tointeger();
        
            // Configure the clock frequency
            local D = oct << 12 | dac << 2 | POW;
            local i2c_result = _i2c.write(ADDRESS, (D >> 8).tochar() + D.tochar()); 
		
		    // Log the true clock frequency
		    freqHz = math.pow(2,oct.tofloat())*(2078.0/(2-dac.tofloat()/1024.0));

            // Return i2c result
            return i2c_result;  
        }
  
    }
    
    function round(val, decimalPoints) {
        local f = math.pow(10, decimalPoints) * 1.0;
        local newVal = val * f;
        newVal = math.floor(newVal + 0.5)
        newVal = (newVal * 1.0) / f;
 
        return newVal;
    }
}

class ShiftReg {
    
    // Serial, RClock, and SClock pins
    ser = null;
    rck = null; 
    sck = null; 
    
    // Output register
    out = 0
    // Register bit meanings
    // b0-3:    MUX16 address
    // b4:      0:  MUX16A      1: MUX16B
    // b5-6     00: Ztest       11: Plate mode
    // b7       0:  Plate off   1: Plate on
    
    // Construct the Object
    constructor() {
        
        hardware.pin2.configure(DIGITAL_OUT);
        hardware.pin5.configure(DIGITAL_OUT);
        hardware.pin7.configure(DIGITAL_OUT);
        
        rck = hardware.pin2;
        sck = hardware.pin5;
        ser = hardware.pin7;
        
        // Bring RClock and SClock HIGH to start
        rck.write(1);
        sck.write(1);
        
        // Zero the output pins
        clear();

    }
    
    function clear() {
        /*
		Clears the 8-bit output state of the 74HC95 register
		
        Inputs:
            N/A
        
        Returns:
            N/A
        */
        
        setByte(0);
    }
    
    function setByte(byte) {
        /*
		Sets the 8-bit state resiter of the 74HC95
		
        Inputs:
            Byte: byte specifying parallel port state, e.g. 170 = 10101010
        
        Returns:
            Error code
        */
        
        if (byte > 255) {
            
            // Value too large
            return -1;
        }
        else {
            
            out = byte;
            
            // Success
            return 0;
        }   
            
    }
    
    function setBit(idx, val) {
        /*
		Sets a single specified bit within the 8-bit state register of the 74HC95
		
        Inputs:
            idx: position of bit to apply val; 0 though 7
            val: value of position idx; 0 or 1
            
        Returns:
            Error code
        */
        
        if (idx > 7 || idx < 0) {
            
            // idx too large or negative
            return -1;
        }
        else {
            
            if (val > 1 || val < 0) {
                
                // Val must be 0 or 1
                return -1;
            }
            else {
                
                // Set single bit
                out = (out & ~(1 << idx)) | val << idx;

                // Success
                return 0;
            }


        } 
        
    }
    
    function update() {
        /*
		Updates the output pins of the 74HC95 based upon the value of this.out
		
        Inputs:
            N/A
        
        Returns:
            N/A
        */
        
        rck.write(0);
            
        for (local idx = 7; idx >= 0; idx -= 1) {
            
            sck.write(0);
            ser.write(out >> idx & 1);
            sck.write(1);
        }
        
        rck.write(1);
    }

}

class Mux {
    
    // Shift register object
    _sr  = null;
    
    // Construct the Object
    constructor(sr) {
        _sr  = sr;
    }
    
    function setMode(mode) {
        /*
		Sets the mode of the autoimpedance board. Available modes are impedance
		testing and plating modes.
		
        Inputs:
            mode:   "ztest" to select impedance testing mode
                    "plate" to select plating mode
            
        Returns:
            Error code
        */

        switch (mode) {
            case "ztest":
                _sr.setBit(5, 0);
                _sr.setBit(6, 0);
                _sr.update();
                break;
            
            case "plate":
                _sr.setBit(5, 1);
                _sr.setBit(6, 1);
                _sr.update();
                break;
                
            default:
                sq_throwerror(mode,"invalid mode.");
                return -1;
        }
    }
    
    function setChannel(chan) {
        /*
		Selects the channel to be measured or plated.
		
        Inputs:
            chan: Channel number; 0-31
            
        Returns:
            Error code
        */
        
        if (chan >= 32 || chan < 0) {
            
            // Channel number is too high or negative
            return -1;   
        }
        else {
            
            // Set the MUX16 address
            _sr.out = (_sr.out & ~0x0F) | chan
            
            // Select which MUX16 to use
            if (chan <= 15) {
                _sr.setBit(4, 0) // MUX16b
            }
            else {
                _sr.setBit(4, 1) // MUX16a
            }
            
            server.log(_sr.out);
            
            _sr.update();
            
            // Success
            return 0;
        }
    }
}


// Configure i2c bus
hardware.i2c89.configure(CLOCK_SPEED_100_KHZ);

// Assign globals
pot <- Pot(hardware.i2c89);
clock <- Clock(hardware.i2c89);
zsensor <- ZSensor(hardware.i2c89,clock);
sr <- ShiftReg();
mux <- Mux(sr);

// Test script
server.log("Autoimpedance is running...")


local result = clock.setHz(10e3); 
if (result == 0) {
    server.log("LTC6904 clock frequency set to " + clock.freqHz + " Hz.");
}


local result = pot.setR(20e3); 
if (result == 0) {
    server.log("AD5245 A->W resistance set to " + pot.Raw + " Ohms.");
}


mux.setMode("ztest");
mux.setChannel(5);
